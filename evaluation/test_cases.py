# -*- coding: utf-8 -*-
"""
================================================================================
테스트 케이스 모듈 (Test Cases Module)
================================================================================

프롬프트 엔지니어링 실험을 위한 테스트 케이스를 정의하는 모듈입니다.

## 왜 테스트 케이스가 필요한가?

프롬프트의 성능을 측정하려면 **정답이 있는 문제**가 필요합니다.
"이 프롬프트가 좋아 보인다"가 아닌, 정량적으로 측정해야 합니다.

예시:
- "기본 프롬프트는 10문제 중 7개를 맞췄다" (70% 정확도)
- "CoT 프롬프트는 10문제 중 9개를 맞췄다" (90% 정확도)
- → CoT가 +20%p 더 효과적이다!

## 테스트 케이스 구성

| 카테고리 | 개수 | 용도 |
|----------|------|------|
| 수학 문제 | 40개 | 계산 능력 평가 |
| 논리 문제 | 23개 | 추론 능력 평가 |
| 분류 문제 | 40개 | 이해/분류 능력 평가 |
| **총계** | **103개** | - |

## 난이도 분류

| 난이도 | 설명 | CoT 효과 |
|--------|------|----------|
| easy | 단순 연산, 직관적 답 | 효과 적음 |
| medium | 2단계 연산, 약간의 추론 | 효과 있음 |
| hard | 다단계 추론 필요 | **효과 큼** |

## 학술적 배경

이 테스트 케이스 설계는 다음을 참고했습니다:
- GSM8K: Google의 초등학교 수학 문제 데이터셋 (8,500개 문제)
- BIG-Bench: Google의 대규모 언어 모델 벤치마크
- MMLU: 다양한 주제의 객관식 문제 모음

## 사용 예시

```python
from evaluation.test_cases import (
    get_math_test_suite,
    get_logic_test_suite,
    get_classification_test_suite,
    get_hard_problems_suite
)

# 수학 문제 가져오기
math_suite = get_math_test_suite()
print(f"총 {len(math_suite)}개 문제")

# 리스트로 변환 (evaluator에서 사용)
test_cases = math_suite.to_list()

# 난이도로 필터링
hard_only = math_suite.filter_by_difficulty("hard")
```

Author: Prompt Engineering Portfolio Project
Created: 2025-01-19
================================================================================
"""

from dataclasses import dataclass
from typing import List, Dict, Any


# ============================================================================
# 데이터 클래스: 단일 테스트 케이스
# ============================================================================

@dataclass
class TestCase:
    """
    단일 테스트 케이스를 표현하는 데이터 클래스

    Attributes:
        input: 프롬프트 템플릿에 들어갈 변수들
               예: {"q": "1+1은?"} → 템플릿 "{q}"에 대입
        expected: 기대하는 정답
                  예: "2"
        category: 문제 카테고리 (수학, 논리, 감성분석 등)
        difficulty: 난이도 (easy, medium, hard)

    Example:
        >>> case = TestCase(
        ...     input={"q": "5 + 3은?"},
        ...     expected="8",
        ...     category="사칙연산",
        ...     difficulty="easy"
        ... )
    """
    input: Dict[str, Any]  # 프롬프트에 들어갈 변수
    expected: str          # 기대하는 정답
    category: str = ""     # 카테고리 (수학, 논리, 요약 등)
    difficulty: str = ""   # 난이도 (easy, medium, hard)


# ============================================================================
# 테스트 스위트 클래스: 테스트 케이스 모음
# ============================================================================

class TestSuite:
    """
    테스트 케이스들을 관리하는 컨테이너 클래스

    ## 제공하는 기능

    1. add(): 새 테스트 케이스 추가
    2. to_list(): evaluator에서 사용할 수 있는 형식으로 변환
    3. filter_by_difficulty(): 난이도로 필터링
    4. filter_by_category(): 카테고리로 필터링

    ## 사용 예시

    ```python
    suite = TestSuite("수학 문제")

    # 테스트 케이스 추가
    suite.add({"q": "1+1?"}, "2", "사칙연산", "easy")

    # evaluator에서 사용할 형식으로 변환
    test_cases = suite.to_list()
    # → [{"input": {"q": "1+1?"}, "expected": "2", ...}]
    ```
    """

    def __init__(self, name: str, cases: List[TestCase] = None):
        """
        테스트 스위트 초기화

        Args:
            name: 테스트 스위트 이름 (예: "수학 문제")
            cases: 초기 테스트 케이스 리스트 (선택)
        """
        self.name = name
        self.cases = cases or []

    def add(
        self,
        input_data: Dict,
        expected: str,
        category: str = "",
        difficulty: str = "medium"
    ):
        """
        새 테스트 케이스를 추가합니다.

        Args:
            input_data: 프롬프트에 들어갈 변수들
            expected: 기대하는 정답
            category: 문제 카테고리
            difficulty: 난이도 (easy/medium/hard)
        """
        self.cases.append(TestCase(input_data, expected, category, difficulty))

    def to_list(self) -> List[Dict]:
        """
        evaluator.evaluate_batch()에서 사용할 수 있는 형식으로 변환합니다.

        Returns:
            List[Dict]: 테스트 케이스 딕셔너리 리스트

        Example:
            >>> suite.to_list()
            [{"input": {"q": "1+1?"}, "expected": "2", "category": "...", "difficulty": "..."}]
        """
        return [
            {
                "input": c.input,
                "expected": c.expected,
                "category": c.category,
                "difficulty": c.difficulty
            }
            for c in self.cases
        ]

    def filter_by_difficulty(self, difficulty: str) -> 'TestSuite':
        """
        특정 난이도의 테스트 케이스만 필터링합니다.

        Args:
            difficulty: 필터링할 난이도 (easy/medium/hard)

        Returns:
            TestSuite: 필터링된 새 테스트 스위트
        """
        filtered = TestSuite(f"{self.name} ({difficulty})")
        filtered.cases = [c for c in self.cases if c.difficulty == difficulty]
        return filtered

    def filter_by_category(self, category: str) -> 'TestSuite':
        """
        특정 카테고리의 테스트 케이스만 필터링합니다.

        Args:
            category: 필터링할 카테고리

        Returns:
            TestSuite: 필터링된 새 테스트 스위트
        """
        filtered = TestSuite(f"{self.name} ({category})")
        filtered.cases = [c for c in self.cases if c.category == category]
        return filtered

    def __len__(self):
        """테스트 케이스 개수 반환"""
        return len(self.cases)


# ============================================================================
# 수학 문제 테스트 케이스 (40개)
# ============================================================================

def get_math_test_suite() -> TestSuite:
    """
    수학 문제 테스트 케이스를 생성합니다.

    ## 구성

    | 유형 | 개수 | 난이도 | 설명 |
    |------|------|--------|------|
    | 단순 사칙연산 | 10개 | easy | 5+3=?, 12-7=? |
    | 복합 연산 | 10개 | medium | 5+3x2=?, (4+6)x2=? |
    | 문장형 문제 | 20개 | hard | "철수는 사과 5개가..." |

    ## 왜 이렇게 구성했는가?

    1. **단순 문제 (easy)**: 기본 성능 확인용
       - 모든 프롬프트 방식이 잘 맞춰야 함
       - 여기서 틀리면 모델 자체에 문제

    2. **복합 문제 (medium)**: 연산 순서 이해 확인
       - 구조화 프롬프트의 효과를 볼 수 있음

    3. **문장형 문제 (hard)**: CoT의 진가 발휘
       - 단계별 사고가 필요한 문제
       - Chain of Thought가 크게 효과적

    Returns:
        TestSuite: 수학 문제 테스트 스위트 (40개)
    """
    suite = TestSuite("수학 문제")

    # =========================================================================
    # 단순 사칙연산 (10개) - easy
    # 목적: 기본적인 계산 능력 확인
    # 기대: 모든 프롬프트 방식에서 100% 정확도
    # =========================================================================
    suite.add({"q": "5 + 3은?"}, "8", "사칙연산", "easy")
    suite.add({"q": "12 - 7은?"}, "5", "사칙연산", "easy")
    suite.add({"q": "6 x 4는?"}, "24", "사칙연산", "easy")
    suite.add({"q": "20 / 5는?"}, "4", "사칙연산", "easy")
    suite.add({"q": "15 + 8은?"}, "23", "사칙연산", "easy")
    suite.add({"q": "30 - 12는?"}, "18", "사칙연산", "easy")
    suite.add({"q": "7 x 8은?"}, "56", "사칙연산", "easy")
    suite.add({"q": "36 / 6은?"}, "6", "사칙연산", "easy")
    suite.add({"q": "9 + 11은?"}, "20", "사칙연산", "easy")
    suite.add({"q": "100 - 37은?"}, "63", "사칙연산", "easy")

    # =========================================================================
    # 복합 연산 (10개) - medium
    # 목적: 연산 순서(PEMDAS) 이해 확인
    # 기대: 구조화 프롬프트가 기본보다 약간 높은 정확도
    # =========================================================================
    suite.add({"q": "5 + 3 x 2는?"}, "11", "복합연산", "medium")
    suite.add({"q": "10 - 2 + 3은?"}, "11", "복합연산", "medium")
    suite.add({"q": "(4 + 6) x 2는?"}, "20", "복합연산", "medium")
    suite.add({"q": "20 / 4 + 5는?"}, "10", "복합연산", "medium")
    suite.add({"q": "3 x 4 + 2 x 5는?"}, "22", "복합연산", "medium")
    suite.add({"q": "(15 - 5) / 2는?"}, "5", "복합연산", "medium")
    suite.add({"q": "8 + 4 x 3 - 2는?"}, "18", "복합연산", "medium")
    suite.add({"q": "100 / 10 / 2는?"}, "5", "복합연산", "medium")
    suite.add({"q": "(3 + 7) x (2 + 3)은?"}, "50", "복합연산", "medium")
    suite.add({"q": "2 x 2 x 2 x 2는?"}, "16", "복합연산", "medium")

    # =========================================================================
    # 문장형 문제 (20개) - hard
    # 목적: Chain of Thought의 효과 검증
    # 기대: CoT 프롬프트가 기본 프롬프트보다 크게 높은 정확도
    #
    # 이 유형의 문제는 GSM8K 데이터셋과 유사하게 설계되었습니다.
    # GSM8K는 Google이 Chain of Thought 연구에 사용한 대표적인 벤치마크입니다.
    # =========================================================================

    # 2단계 문제: 단순한 다단계 연산
    suite.add(
        {"q": "철수는 사과 5개가 있었습니다. 2개를 먹었습니다. 남은 사과는 몇 개인가요?"},
        "3", "문장형", "hard"
    )
    suite.add(
        {"q": "영희는 1000원이 있었습니다. 300원짜리 과자를 샀습니다. 남은 돈은 얼마인가요?"},
        "700", "문장형", "hard"
    )
    suite.add(
        {"q": "교실에 학생 20명이 있었습니다. 5명이 나갔습니다. 남은 학생은 몇 명인가요?"},
        "15", "문장형", "hard"
    )
    suite.add(
        {"q": "바구니에 귤 12개가 있습니다. 4개를 더 넣었습니다. 귤은 모두 몇 개인가요?"},
        "16", "문장형", "hard"
    )

    # 3단계 문제: 정보를 순서대로 처리해야 함
    suite.add(
        {"q": "철수는 사과 5개가 있었습니다. 2개를 먹고, 3개를 더 받았습니다. 지금 사과는 몇 개인가요?"},
        "6", "문장형", "hard"
    )
    suite.add(
        {"q": "버스에 12명이 타고 있었습니다. 첫 번째 정류장에서 4명이 내리고, 7명이 탔습니다. 버스에 몇 명이 있나요?"},
        "15", "문장형", "hard"
    )
    suite.add(
        {"q": "민수는 2000원이 있었습니다. 500원짜리 음료수를 사고, 할머니께 1000원을 받았습니다. 지금 얼마가 있나요?"},
        "2500", "문장형", "hard"
    )
    suite.add(
        {"q": "도서관에서 책 5권을 빌렸습니다. 2권을 읽고 반납했습니다. 3권을 더 빌렸습니다. 지금 몇 권을 빌린 상태인가요?"},
        "6", "문장형", "hard"
    )
    suite.add(
        {"q": "상자에 공 15개가 있습니다. 6개를 꺼내고, 4개를 넣었습니다. 상자에 공이 몇 개 있나요?"},
        "13", "문장형", "hard"
    )

    # 곱셈/나눗셈 문장형: 단위 변환이나 분배 문제
    suite.add(
        {"q": "사탕 24개를 6명에게 똑같이 나눠주면 한 명당 몇 개를 받나요?"},
        "4", "문장형", "hard"
    )
    suite.add(
        {"q": "한 봉지에 과자가 8개씩 들어있습니다. 3봉지를 사면 과자는 모두 몇 개인가요?"},
        "24", "문장형", "hard"
    )
    suite.add(
        {"q": "연필 5다스를 샀습니다. 1다스는 12자루입니다. 연필은 모두 몇 자루인가요?"},
        "60", "문장형", "hard"
    )
    suite.add(
        {"q": "빵 30개를 한 상자에 6개씩 담으면 상자가 몇 개 필요한가요?"},
        "5", "문장형", "hard"
    )

    # 복합 연산 문장형: 여러 종류의 연산을 조합
    suite.add(
        {"q": "1000원짜리 물건 2개와 500원짜리 물건 3개를 샀습니다. 총 얼마인가요?"},
        "3500", "문장형", "hard"
    )
    suite.add(
        {"q": "학생 30명이 4명씩 모둠을 만들면, 모둠이 몇 개 생기고 남는 학생은 몇 명인가요? (남는 학생 수만 답하세요)"},
        "2", "문장형", "hard"
    )
    suite.add(
        {"q": "가로 8cm, 세로 5cm인 직사각형의 넓이는 몇 cm²인가요?"},
        "40", "문장형", "hard"
    )
    suite.add(
        {"q": "한 변이 6cm인 정사각형의 둘레는 몇 cm인가요?"},
        "24", "문장형", "hard"
    )

    # 비교/합산 문장형: 여러 값을 비교하거나 합산
    suite.add(
        {"q": "철수는 사탕 15개, 영희는 사탕 23개를 가지고 있습니다. 두 사람의 사탕을 합하면 몇 개인가요?"},
        "38", "문장형", "hard"
    )
    suite.add(
        {"q": "형은 12살, 동생은 8살입니다. 형과 동생의 나이 차이는 몇 살인가요?"},
        "4", "문장형", "hard"
    )
    suite.add(
        {"q": "아버지의 나이는 40살이고, 아들의 나이는 아버지 나이의 절반보다 5살 적습니다. 아들의 나이는 몇 살인가요?"},
        "15", "문장형", "hard"
    )

    return suite


# ============================================================================
# 논리 문제 테스트 케이스 (23개)
# ============================================================================

def get_logic_test_suite() -> TestSuite:
    """
    논리 문제 테스트 케이스를 생성합니다.

    ## 구성

    | 유형 | 개수 | 설명 |
    |------|------|------|
    | 삼단논법 | 3개 | "모든 A는 B, C는 A, 따라서 C는 B?" |
    | 비교/순서 | 4개 | "A>B, B>C, 가장 큰 것은?" |
    | 조건 추론 | 3개 | "비가 오면 우산, 지금 우산 → 비가 오나?" |
    | 복합 추론 | 3개 | 여러 조건을 조합 |
    | 패턴 인식 | 5개 | "2, 4, 6, 8, ?" |
    | 상식 | 5개 | "1년은 몇 개월?" |

    ## 왜 이런 문제들인가?

    논리 문제는 **추론 능력**을 테스트합니다.
    특히 삼단논법의 역(逆) 오류 문제는 LLM이 자주 틀리는 유형입니다.

    예시:
    - "모든 학생은 교복을 입는다"
    - "철수는 교복을 입고 있다"
    - → "철수는 학생이다?" (정답: 아니오! 역은 항상 참이 아님)

    Returns:
        TestSuite: 논리 문제 테스트 스위트 (23개)
    """
    suite = TestSuite("논리 문제")

    # =========================================================================
    # 삼단논법 (3개)
    # 대전제 + 소전제 → 결론
    # 주의: 역(逆)은 항상 참이 아님!
    # =========================================================================
    suite.add(
        {"q": "모든 고양이는 동물입니다. 나비는 고양이입니다. 나비는 동물인가요? (예/아니오)"},
        "예", "삼단논법", "medium"
    )
    suite.add(
        {"q": "모든 새는 날개가 있습니다. 참새는 새입니다. 참새는 날개가 있나요? (예/아니오)"},
        "예", "삼단논법", "medium"
    )
    # 역 오류 문제: LLM이 자주 틀림
    suite.add(
        {"q": "모든 물고기는 물에서 삽니다. 고래는 물에서 삽니다. 고래는 물고기인가요? (예/아니오)"},
        "아니오", "삼단논법", "hard"
    )

    # =========================================================================
    # 순서/비교 (4개)
    # A > B > C 형태의 관계 파악
    # =========================================================================
    suite.add(
        {"q": "A가 B보다 크고, B가 C보다 큽니다. A, B, C 중 가장 큰 것은?"},
        "A", "비교", "medium"
    )
    suite.add(
        {"q": "철수가 영희보다 키가 크고, 영희가 민수보다 키가 큽니다. 가장 키가 작은 사람은?"},
        "민수", "비교", "medium"
    )
    suite.add(
        {"q": "사과가 배보다 비싸고, 배가 귤보다 비쌉니다. 가장 싼 과일은?"},
        "귤", "비교", "medium"
    )
    suite.add(
        {"q": "A는 B의 왼쪽에 있고, C는 B의 오른쪽에 있습니다. 가운데 있는 것은?"},
        "B", "위치", "medium"
    )

    # =========================================================================
    # 조건 추론 (3개)
    # if-then 관계와 그 역, 대우 관계
    # =========================================================================
    suite.add(
        {"q": "비가 오면 우산을 씁니다. 지금 비가 오고 있습니다. 우산을 써야 하나요? (예/아니오)"},
        "예", "조건추론", "easy"
    )
    # 역 오류: "P→Q"가 참이어도 "Q→P"가 참은 아님
    suite.add(
        {"q": "비가 오면 우산을 씁니다. 지금 우산을 쓰고 있습니다. 반드시 비가 오고 있나요? (예/아니오)"},
        "아니오", "조건추론", "hard"
    )
    suite.add(
        {"q": "모든 학생은 교복을 입습니다. 철수는 교복을 입고 있습니다. 철수는 반드시 학생인가요? (예/아니오)"},
        "아니오", "조건추론", "hard"
    )

    # =========================================================================
    # 복합 추론 (3개)
    # 여러 조건을 조합해서 결론 도출
    # =========================================================================
    suite.add(
        {"q": "빨강, 파랑, 노랑 공이 있습니다. 빨강 공은 파랑 공보다 무겁고, 노랑 공은 빨강 공보다 무겁습니다. 가장 가벼운 공의 색깔은?"},
        "파랑", "복합추론", "hard"
    )
    suite.add(
        {"q": "철수, 영희, 민수가 달리기를 했습니다. 철수는 1등이 아니고, 민수는 영희보다 빨랐습니다. 영희는 몇 등인가요?"},
        "3", "복합추론", "hard"
    )
    suite.add(
        {"q": "A, B, C 세 사람이 있습니다. A는 거짓말쟁이가 아닙니다. B는 'A는 거짓말쟁이다'라고 말했습니다. B는 거짓말쟁이인가요? (예/아니오)"},
        "예", "복합추론", "hard"
    )

    # =========================================================================
    # 패턴 인식 (5개)
    # 수열의 규칙을 파악
    # =========================================================================
    suite.add({"q": "2, 4, 6, 8, ? 다음 숫자는?"}, "10", "패턴", "easy")
    suite.add({"q": "1, 4, 9, 16, ? 다음 숫자는?"}, "25", "패턴", "medium")  # 제곱수
    suite.add({"q": "1, 1, 2, 3, 5, 8, ? 다음 숫자는?"}, "13", "패턴", "medium")  # 피보나치
    suite.add({"q": "3, 6, 9, 12, ? 다음 숫자는?"}, "15", "패턴", "easy")
    suite.add({"q": "1, 2, 4, 8, ? 다음 숫자는?"}, "16", "패턴", "easy")  # 2의 거듭제곱

    # =========================================================================
    # 상식 (5개)
    # 기본적인 사실 확인
    # =========================================================================
    suite.add({"q": "월요일 다음 날은 무슨 요일인가요?"}, "화요일", "상식", "easy")
    suite.add({"q": "1년은 몇 개월인가요?"}, "12", "상식", "easy")
    suite.add({"q": "하루는 몇 시간인가요?"}, "24", "상식", "easy")

    return suite


# ============================================================================
# 분류 문제 테스트 케이스 (40개)
# ============================================================================

def get_classification_test_suite() -> TestSuite:
    """
    감성 분류 테스트 케이스를 생성합니다.

    ## 구성

    | 감성 | 개수 | 예시 |
    |------|------|------|
    | 긍정 | 15개 | "정말 좋아요!", "최고예요" |
    | 부정 | 15개 | "실망이에요", "별로예요" |
    | 중립 | 10개 | "보통이에요", "그저 그래요" |

    ## 왜 감성 분류인가?

    감성 분류는 **Few-shot Learning** 실험에 적합합니다.
    예시를 몇 개 보여주면 패턴을 학습하는지 확인할 수 있습니다.

    ## 난이도 기준

    | 난이도 | 기준 |
    |--------|------|
    | easy | 명확한 감정 단어 포함 ("좋아요", "싫어요") |
    | medium | 간접적인 표현 ("다음에 또 올게요") |
    | hard | 애매한 표현 ("나쁘지 않아요" = 긍정? 중립?) |

    Returns:
        TestSuite: 분류 문제 테스트 스위트 (40개)
    """
    suite = TestSuite("감성 분류")

    # =========================================================================
    # 긍정 (15개)
    # =========================================================================
    suite.add({"text": "이 영화 정말 재미있었어요!"}, "긍정", "감성분석", "easy")
    suite.add({"text": "서비스가 훌륭합니다. 다음에 또 올게요."}, "긍정", "감성분석", "easy")
    suite.add({"text": "최고의 경험이었습니다."}, "긍정", "감성분석", "easy")
    suite.add({"text": "정말 만족스러운 제품이에요."}, "긍정", "감성분석", "easy")
    suite.add({"text": "직원분들이 너무 친절하셨어요."}, "긍정", "감성분석", "easy")
    suite.add({"text": "가격 대비 품질이 훌륭해요."}, "긍정", "감성분석", "medium")
    suite.add({"text": "기대 이상이었어요!"}, "긍정", "감성분석", "easy")
    suite.add({"text": "완벽한 하루였습니다."}, "긍정", "감성분석", "easy")
    suite.add({"text": "다음에 꼭 다시 방문할게요!"}, "긍정", "감성분석", "easy")
    suite.add({"text": "이렇게 좋은 건 처음이에요."}, "긍정", "감성분석", "easy")
    suite.add({"text": "강력 추천합니다!"}, "긍정", "감성분석", "easy")
    suite.add({"text": "정말 감동받았어요."}, "긍정", "감성분석", "easy")
    suite.add({"text": "모든 게 완벽했습니다."}, "긍정", "감성분석", "easy")
    suite.add({"text": "너무 행복한 시간이었어요."}, "긍정", "감성분석", "easy")
    suite.add({"text": "친구들한테도 추천해야겠어요."}, "긍정", "감성분석", "medium")

    # =========================================================================
    # 부정 (15개)
    # =========================================================================
    suite.add({"text": "너무 실망스러웠어요."}, "부정", "감성분석", "easy")
    suite.add({"text": "다시는 안 갈 것 같아요."}, "부정", "감성분석", "easy")
    suite.add({"text": "시간 낭비였습니다."}, "부정", "감성분석", "easy")
    suite.add({"text": "서비스가 너무 불친절해요."}, "부정", "감성분석", "easy")
    suite.add({"text": "품질이 기대에 못 미쳤어요."}, "부정", "감성분석", "easy")
    suite.add({"text": "이 가격에 이 정도면 별로예요."}, "부정", "감성분석", "medium")
    suite.add({"text": "환불받고 싶어요."}, "부정", "감성분석", "easy")
    suite.add({"text": "최악의 경험이었습니다."}, "부정", "감성분석", "easy")
    suite.add({"text": "돈이 아까워요."}, "부정", "감성분석", "easy")
    suite.add({"text": "다시는 이용 안 할 거예요."}, "부정", "감성분석", "easy")
    suite.add({"text": "정말 화가 났어요."}, "부정", "감성분석", "easy")
    suite.add({"text": "기대를 완전히 저버렸어요."}, "부정", "감성분석", "easy")
    suite.add({"text": "이건 사기예요."}, "부정", "감성분석", "easy")
    suite.add({"text": "절대 추천하지 않습니다."}, "부정", "감성분석", "easy")
    suite.add({"text": "후회되는 선택이었어요."}, "부정", "감성분석", "easy")

    # =========================================================================
    # 중립 (10개)
    # 가장 분류하기 어려운 유형
    # =========================================================================
    suite.add({"text": "그냥 그랬어요."}, "중립", "감성분석", "medium")
    suite.add({"text": "보통이에요."}, "중립", "감성분석", "medium")
    suite.add({"text": "특별히 좋지도 나쁘지도 않아요."}, "중립", "감성분석", "medium")
    suite.add({"text": "기대한 만큼이었어요."}, "중립", "감성분석", "hard")
    suite.add({"text": "평범했습니다."}, "중립", "감성분석", "medium")
    suite.add({"text": "나쁘지 않았어요."}, "중립", "감성분석", "hard")  # 애매함
    suite.add({"text": "딱 평균 수준이에요."}, "중립", "감성분석", "medium")
    suite.add({"text": "그저 그래요."}, "중립", "감성분석", "medium")
    suite.add({"text": "무난했습니다."}, "중립", "감성분석", "medium")
    suite.add({"text": "특별한 건 없었어요."}, "중립", "감성분석", "medium")

    return suite


# ============================================================================
# 유틸리티 함수
# ============================================================================

def get_all_test_suites() -> Dict[str, TestSuite]:
    """
    모든 테스트 스위트를 딕셔너리로 반환합니다.

    Returns:
        Dict[str, TestSuite]: {"math": ..., "logic": ..., "classification": ...}
    """
    return {
        "math": get_math_test_suite(),
        "logic": get_logic_test_suite(),
        "classification": get_classification_test_suite(),
    }


def get_hard_problems_suite() -> TestSuite:
    """
    어려운 문제만 모은 테스트 스위트를 생성합니다.

    ## 용도

    Chain of Thought (CoT) 프롬프팅의 효과를 검증하기 위한 테스트 세트입니다.
    CoT는 어려운 문제에서 효과가 크므로, hard 난이도 문제만 모았습니다.

    ## 구성

    - 수학 문장형 문제 (hard)
    - 논리 추론 문제 (hard)

    Returns:
        TestSuite: 어려운 문제 테스트 스위트
    """
    suite = TestSuite("어려운 문제 (CoT 테스트용)")

    # 수학 문제 중 hard
    math = get_math_test_suite()
    for case in math.cases:
        if case.difficulty == "hard":
            suite.cases.append(case)

    # 논리 문제 중 hard
    logic = get_logic_test_suite()
    for case in logic.cases:
        if case.difficulty == "hard":
            suite.cases.append(case)

    return suite


def print_test_suite_stats():
    """
    테스트 케이스 통계를 출력합니다.

    ## 출력 예시

    ```
    ==================================================
    테스트 케이스 통계
    ==================================================

    [수학 문제] 총 40개
      난이도: {'easy': 10, 'medium': 10, 'hard': 20}
      카테고리: {'사칙연산': 10, '복합연산': 10, '문장형': 20}
    ...

    총 테스트 케이스: 103개
    ==================================================
    ```
    """
    suites = get_all_test_suites()

    print("=" * 50)
    print("테스트 케이스 통계")
    print("=" * 50)

    total = 0
    for name, suite in suites.items():
        print(f"\n[{suite.name}] 총 {len(suite)}개")

        # 난이도별 통계
        difficulties = {}
        categories = {}
        for case in suite.cases:
            difficulties[case.difficulty] = difficulties.get(case.difficulty, 0) + 1
            categories[case.category] = categories.get(case.category, 0) + 1

        print(f"  난이도: {difficulties}")
        print(f"  카테고리: {categories}")
        total += len(suite)

    print(f"\n총 테스트 케이스: {total}개")
    print("=" * 50)


# ============================================================================
# 모듈 직접 실행 시 통계 출력
# ============================================================================

if __name__ == "__main__":
    print_test_suite_stats()
